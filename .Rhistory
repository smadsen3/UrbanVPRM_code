library(dplyr)
library(ncdf4)
library(data.table)
library(ggplot2)
library(parallel)
library(StreamMetabolism) #for sunrise/sunset times
library(lubridate) #for converting date formats
library(zoo)
#Toronto:
xmin = -79.7
xmax = -79.1
ymin =  43.5
ymax =  43.9
# Create slightly larger bounding box to crop to (avoids dropped pixels at edge when reprojecting / resampling)
bbox <- extent(xmin,xmax,ymin,ymax)
buff=0.05
bbox.extra <- extent(xmin - buff, xmax + buff, ymin - buff, ymax + buff)
yr = 2021
GOES_CRS = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 "
# Create extended bounding box raster in GOES projection
gridXY = as(raster::extent(bbox.extra), "SpatialPolygons")
proj4string(gridXY) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
GOES.XY <- projectRaster(raster(gridXY),crs=GOES_CRS)
inDIR <-'C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GOES/2021/'
rl <- list.files(path=inDIR,pattern='GOES') # GOES data downloaded from ftp://eftp.ifremer.fr/cersat-rt/project/osi-saf/data/radflux/
rl
length(rl)
times <- fread(paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2021/times',yr,'.csv')) # times data in /urbanVPRM_30m/driver_data/times/
GOES_raster<- function(dir,dt){
name_list<-NULL
file<-rl[grep(as.character(dt),rl)]
if(file.exists(paste0(dir,file))){
print(paste0("Processing file ", file))
rs <- raster(paste0(dir,file),varname = 'ssi')
rs_c <- raster(paste0(dir,file),varname = 'ssi_confidence_level')
goes.crop <- crop(rs,bbox.extra)
goes_QF <-copy(goes.crop)
goes_QF[goes_QF<3]<-NA #remove any data with confidence level less than acceptable
#goes_proj <- resample(goes_3,GOES.XY)
#goes_stk<-stack(goes.crop,goes_3)
#names(goes_stk)<-c(ssi,ssi_QC)
names(goes_QF)<-substr(file,1,10)
}else{
print(paste0("Accounting for missing file ", dt))
rs <- raster(paste0(dir,rl[1]),varname = 'ssi')
goes.crop <- crop(rs,bbox.extra)
goes_QF <-copy(goes.crop)
goes_QF<-goes_QF*NA
names(goes_QF)<-as.character(dt)
}
return(goes_QF)
}
outlist <- mcmapply(GOES_raster, dir=inDIR, dt=times$datetime, mc.cores=1)
names(outlist)<-as.character(times$datetime)
#names(GOES.proj)<-substr(rl[idx_1],1,10)
st<-stack(outlist)
#cnames <-names(st)
#cnames[1] <-"X2019043023"
#names(st)<-cnames
cnames<-names(outlist)
dt<-as.data.table(as.data.frame(st,xy=T))
setnames(dt,c('x','y',cnames))
dt <-setDT(dt)
dm <- melt.data.table(dt,id.vars=c('x','y'),variable.name='datetime',value.name='swrad',variable.factor=F)
dm[,datetime:=as.character(datetime)][,swrad:=as.numeric(swrad)]
setkey(dm,x,y,datetime)
centX <- mean(xmin-buff,xmax+buff)
centY <- mean(ymin-buff,ymax+buff)
#
sun.rise <- function(x){
y <- sunrise.set(centY,centX,paste(substr(x,1,4),substr(x,5,6),substr(x,7,8),sep='/'),timezone='UTC')[1]
return(y)
}
sun.set <- function(x){
y <- sunrise.set(centY,centX,paste(substr(x,1,4),substr(x,5,6),substr(x,7,8),sep='/'),timezone='UTC')[2]
return(y)
}
#Deal with missing night time data
sunrise <- melt.data.table(as.data.table(lapply(times$datetime,sun.rise)),variable.name = 'date', value.name='posTime')
sunrise[,chr:=seq(length(unique(times$chr)))][,riseTime:=as.numeric(substr(as.character(ymd_hms(posTime)),12,13))]
sunrise$date<-substr(sunrise$posTime,1,10)
sunrise<-sunrise[,.(chr,riseTime)]
#sunrise<-sunrise[,.(chr,riseTime)]
setkey(sunrise,chr)
sunset <- melt.data.table(as.data.table(lapply(times$datetime,sun.set)),variable.name = 'date',value.name='posTime')
sunset[,chr:=seq(length(unique(times$chr)))][,setTime:=as.numeric(substr(as.character(ymd_hms(posTime)),12,13))]
sunset$date<-substr(sunset$posTime,1,10)
sunset<-sunset[,.(chr,setTime)]
#sunset <- sunset[,.(chr,setTime)]
setkey(sunset,chr)
#dm2<-copy(dm)
dm[,chr := .GRP, by = .(datetime)]
setkey(dm,chr)
dm <- sunrise[dm]
dm <- sunset[dm]
invisible(gc())
dm[swrad<=0,swrad:=NA]
dm[is.na(swrad) & setTime<riseTime & as.numeric(substr(datetime,9,10))<=riseTime+1 & as.numeric(substr(datetime,9,10))>=setTime-1,swrad:=0]
dm[is.na(swrad) & setTime>riseTime & as.numeric(substr(datetime,9,10))<=riseTime+1,swrad:=0]
dm[is.na(swrad) & setTime>riseTime & as.numeric(substr(datetime,9,10))>=setTime-1,swrad:=0]
setorder(dm,y,x,chr)
len <- dim(dm[chr==1])[1]
dm[,Index := .GRP, by = .(x,y)]
dm <- dm[,.(Index,x,y,datetime,chr,swrad)]
#rap2[,tempK:=round(tempK,2)][,swrad:=round(swrad,2)]
setnames(dm,'chr','HOY')
dm$sw_inter<-dm$swrad
for (i in unique(dm$Index)){#[1:length(unique(clima.dt$Index))]){
ind<-which(dm$Index==i)
#clima.dt$sw_inter[ind]<-na.spline(clima.dt$sw_inter[ind])
dm$sw_inter[ind]<-na.spline(dm$sw_inter[ind])
##if (i==1){
##  ind_length<-sum(is.na(clima.dt$swRad[ind]))
##}else{
##  ind_length<-append(ind_length,sum(is.na(clima.dt$swRad[ind])))
##}
print(i)
}
dm$sw_test<-dm$sw_inter
#Remove interpolated values that are above or below measured values
#hrs<-unique(dm$HOY[dm$sw_inter < -0.01])
hrs<-unique(dm$HOY[dm$sw_inter < min(dm$swrad,na.rm=TRUE) | dm$sw_inter > max(dm$swrad,na.rm=TRUE)])
for (h in hrs) {
#idx<-which(dm$sw_inter<0 & dm$HOY==h)
idx<-which((dm$sw_inter< min(dm$swrad,na.rm=TRUE) | dm$sw_inter> max(dm$swrad,na.rm=TRUE)) & dm$HOY==h)
for (i in idx){
id<-which(dm$x <= dm$x[i]+0.06 & dm$x >= dm$x[i]-0.06 & dm$y <= dm$y[i]+0.06 & dm$y >= dm$y[i]-0.06 & dm$HOY==h)
#xvals<-unique(dm$x[dm$x <= dm$x[i]+0.06 & dm$x >= dm$x[i]-0.06])
#yvals<-unique(dm$x[dm$x <= dm$x[i]+0.06 & dm$x >= dm$x[i]-0.06])
#print(c(dm$x[i],id))#vals))
n<-sum(is.na(dm$swrad[id]))
if(n>=length(id)-1){#if there is 1 or less pixel that is not NA
dm$sw_test[i]<-mean(dm$swrad[dm$HOY==h],na.rm=TRUE) #take the mean of the entire scene
#print(paste(h,i,'scene',sep=' '))
}else{
dm$sw_test[i]<-mean(dm$swrad[id],na.rm=TRUE)
}
#dm$sw_test[i]<-mean(dm$swrad[id],na.rm=TRUE)
#print(c(h,i,id))
}
print(h)
#for (i in length(dm$x[idx])){
#  print(paste0("x: "+str(dm$x[idx][i])+"surrounding: "+str(vals[i])))
#}
}
#replace any remaining values outside of the range with the minimum and maximum of the range
dm$sw_test[dm$sw_inter < min(dm$swrad,na.rm=TRUE) & is.na(dm$sw_test)] <-0
dm$sw_test[dm$sw_inter > max(dm$swrad,na.rm=TRUE) & is.na(dm$sw_test)] <- max(dm$swrad,na.rm=TRUE)
dir.create('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/pre_processed_GOES/',showWarnings=FALSE)
#city<-'GTA_V061_500m_2018'
saveRDS(dm,'C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/pre_processed_GOES/goes_GTA_2021_pre_processed_mean_filling_test_NA_rm.rds')
memory.limit(size=5e8)
memory.limit(size=5e8)
library(StreamMetabolism)
library(rgdal)
library(zoo)
library(purrr)
library(data.table)
library(ncdf4)
library(raster)
library(sp)
library(parallel)
library(lubridate)
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files')
xmin = -79.7
xmax = -79.1
ymin =  43.5
ymax =  43.9
city = 'GTA_V061_500m_2021'
yr = 2021
# Set input and create output files directories
inDIR <- paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GOES/2021/origTIFF/')
outDIR <- paste0(city,'/',yr)
# Time file
times <- fread(paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2021/times',yr,'.csv')) # times data in /urbanVPRM_30m/driver_data/times/
setkey(times,chr)
# CRS list
#LANDSAT_CRS = "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
RAP_CRS = "+proj=lcc +lat_1=25 +lat_2=25 +lat_0=25 +lon_0=265 +x_0=0 +y_0=0 +a=6371229 +b=6371229 +units=m +no_defs"
GOES_CRS = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 "
MODIS_CRS = "+proj=longlat +datum=WGS84 +no_defs"
# Import raster of study domain and convert to SpatialPoints object for resampling
#ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD/landsat/landsat8/ls_TPD2018_0203_8_2km_all_bands.tif') # landsat data in /urbanVPRM_30m/driver_data/landsat/
ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/LandCover/MODIS_V061_LC_GTA_500m_2021.tif')
npixel <- ncell(ls)
values(ls) <- 1
ls.spdf <- as(ls,'SpatialPointsDataFrame')
# Create slightly larger bounding box to crop to (avoids dropped pixels at edge when reprojecting / resampling)
bbox <- extent(xmin,xmax,ymin,ymax)
buff=0.05
bbox.extra <- extent(xmin - buff, xmax + buff, ymin - buff, ymax + buff)
# Create extended bounding box raster in GOES projection
gridXY = as(raster::extent(bbox.extra), "SpatialPolygons")
proj4string(gridXY) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
GOES.XY <- projectRaster(raster(gridXY),crs=GOES_CRS)
print("done! 1")
# Create file list of data to project / crop / resample
rl <- list.files(path=inDIR,pattern='GOES') # GOES data downloaded from ftp://eftp.ifremer.fr/cersat-rt/project/osi-saf/data/radflux/
#goes_data<-readRDS("C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2018/pre_processed_GOES/goes_GTA_2018_pre_processed_mean_filling_test_NA_rm.rds")
goes_data<-readRDS("C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/pre_processed_GOES/goes_GTA_2021_pre_processed_mean_filling_test_NA_rm.rds")
goes_data<-goes_data[,.(x,y,datetime,sw_test)]
outlist<-NULL
for (d in unique(goes_data$datetime)){
m<-copy(ls)
#print(paste0("Processing ",d))
godat<-rasterFromXYZ(goes_data[goes_data$datetime==d])
godat<-godat$sw_test
crs(godat)<-GOES_CRS
#godat<-crop(godat,extent(GOES.XY))
#godat<-projectRaster(godat,crs=MODIS_CRS)
vals<- extract(godat,ls.spdf)
values(m)<-vals
outlist<-append(outlist,m)
}
print("done! 2")
# run function
#outlist <- mcmapply(goes2modis, dir=inDIR, file=rl, mc.cores=1)
rm(ls,ls.spdf,GOES.XY)
# Compile all cropped and reprojected hourly rasters into single "long" data.table
cnames <- as.character(times$datetime)#substr(rl,1,10)
st = stack(outlist)
dt <- as.data.table(as.data.frame(st,xy=T))
setnames(dt,c('x','y',cnames))
print("saved dt")
dt <- setDT(dt)
dm <- melt.data.table(dt,id.vars=c('x','y'),variable.name='datetime',value.name='swrad',variable.factor=F)
dm[,datetime:=as.character(datetime)][,swrad:=as.numeric(swrad)]
setkey(dm,x,y,datetime)
# Load RAP .rds file to join with GOES completed data.table
rap2 <- readRDS(paste0(outDIR,'/rap_',city,'.rds'))#'_',yr,'.rds'))
setkey(rap2,x,y,datetime)
rap2 <- dm[rap2]
td <- times[,.(datetime,hour)]
td$datetime <- as.character(td$datetime)
setkey(td,datetime)
setkey(rap2,datetime)
rap2 <- td[rap2]
rap2[,chr := .GRP, by = .(datetime)]
setkey(rap2,chr)
#rap2 <- sunrise[rap2]
#rap2 <- sunset[rap2]
invisible(gc())
setorder(rap2,y,x,chr)
len <- dim(rap2[chr==1])[1]
rap2[,Index := .GRP, by = .(x,y)]
rap2 <- rap2[,.(Index,x,y,datetime,chr,tempK,swrad)]
rap2[,tempK:=round(tempK,2)][,swrad:=round(swrad,2)]
setnames(rap2,'chr','HOY')
## Convert Temperature to °C
rap2$tempK = rap2$tempK-273.15
colnames(rap2) = c("Index","x","y","datetime","HoY","tmpC","swRad")
# Assign Index values that correspond to all other driver data
rap2 <- rap2[,-1]
# import raster used for indexing
#ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD/landsat/landsat8/ls_TPD2018_0203_8_2km_all_bands.tif') # landsat data in /urbanVPRM_30m/driver_data/landsat/
ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/LandCover/MODIS_V061_LC_GTA_500m_2021.tif')
## Function to convert tif into a datatable..
tifdt_fun = function(raster,name){
dt = as.data.table(as.data.frame(raster, xy=T))
dt = cbind(1:ncell(raster), dt)
setnames(dt,c("Index","x","y",name))
setkey(dt,Index,x,y)
return(dt)
}
Idx.dt = tifdt_fun(ls,"Indexing")
Idx.dt <- Idx.dt[,-4]
colnames(Idx.dt) <- c('Index','x','y')
# Add new Index to the rap/goes data table
rap2 <- Idx.dt[rap2,on = c('x','y'), roll = 'nearest']
setkey(Idx.dt, x,y)
setkey(rap2,x,y)
# Save in RDS binary format to preserve space
saveRDS(rap2,paste0(outDIR,'/rap_goes_',city,'_hourly_fixed.rds'))
memory.limit(size=5e8)
## Load libraries
library("data.table")
library("raster")
library("parallel")
library("foreach")
library("doParallel")
library("ggplot2") #not needed for running just visualizing
## register cores for parallel processes on computing cluster
cores = as.numeric(Sys.getenv("NSLOTS"))
if (is.na(cores)) cores=3
registerDoParallel(cores)
print(paste0("n. of cores is ",cores))
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files')
# Arguments:
city = 'GTA_V061_500m_2021'
yr = 2021
veg_type = 'DBF' #Maybe use Mixed forest instead?
## If area is too big (n of pixels > nrow_block) divide in blocks of nrow_block cells
nrow_block=2500
# Climate data folder
dir_clima = paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/2021') # climate data in /urbanVPRM_30m/driver_data/rap_goes/
## Define the path to the folder where outputs are saved
dir.create(paste0("outputs"), showWarnings = FALSE)
dir.create(paste0("outputs/",city), showWarnings = FALSE)
dir_out = paste0(city)
## Function to convert tif into a datatable..
tifdt_fun = function(raster,name){
dt = as.data.table(as.data.frame(raster, xy=T))
dt = cbind(1:ncell(raster), dt)
setnames(dt,c("Index","x","y",name))
setkey(dt,Index,x,y)
return(dt)
}
### LOAD DATA
## Land cover and ISA
## NEED TO CONVERT LC DATA TO SAME FORMAT AS NLCD DATA
LC = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/LandCover/MODIS_V061_LC_GTA_500m_2021.tif') # Land cover data in /urbanVPRM_30m/driver_data/lc_isa/
LC.dt = tifdt_fun(LC,"LandCover")
ISA_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/ISA/ISA_GTA_GMIS_Toronto_ACI_SOLRIS_500m_2021.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
ISA_dat<-resample(ISA_dat,LC) #for some reason x and y were offset by 1*10^-9 compared to LC raster, fix it by resampling
ISA.dt = tifdt_fun(ISA_dat,"ISA")
C4 = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/LandCover/C4_frac_GTA_500m_2021.tif') # C4 fraction
C4<-resample(C4,LC) #for some reason x and y were offset by 1*10^-9 compared to LC raster, fix it by resampling
C4.dt = tifdt_fun(C4,"C4")
## Merge LC and ISA
#LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index","x","y"))
#for some reason y is off by 1*10^-9 so it won't merge do it manually below:
LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index","x"))
LC_ISA.dt = merge(LC_ISA.dt,C4.dt,by=c("Index","x"))
LC_ISA.test<-LC_ISA.dt[,1:2]
LC_ISA.test$y<-LC_ISA.dt$y.x
LC_ISA.test$LandCover<-LC_ISA.dt$LandCover
LC_ISA.test$ISA<-LC_ISA.dt$ISA
LC_ISA.test$C4<-LC_ISA.dt$C4
LC_ISA.dt<-LC_ISA.test
npixel = as.numeric(nrow(LC_ISA.dt))
print(paste0("n. of pixels is ",npixel))
wtr_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/Impermeable_Surface/SOLRIS_aggregated_water_cover_GTA.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
wtr_dat<-resample(wtr_dat,LC) #for some reason x and y were offset by 1*10^-9 compared to LC raster, fix it by resampling
wtr.dt = tifdt_fun(wtr_dat,"wtr")
rm(ISA_dat,LC.dt,ISA.dt,C4,C4.dt,LC_ISA.test,wtr_dat)
print("LC, ISA & wtr loaded!")
greenup = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_greenup_2021.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
memory.limit(size=5e8)
## Load libraries
library("data.table")
library("raster")
library("parallel")
library("foreach")
library("doParallel")
library("ggplot2") #not needed for running just visualizing
if (is.na(cores)) cores=3
## register cores for parallel processes on computing cluster
cores = as.numeric(Sys.getenv("NSLOTS"))
registerDoParallel(cores)
print(paste0("n. of cores is ",cores))
memory.limit(size=5e8)
## Load libraries
library("data.table")
library("raster")
library("parallel")
library("foreach")
library("doParallel")
library("ggplot2") #not needed for running just visualizing
## register cores for parallel processes on computing cluster
cores = as.numeric(Sys.getenv("NSLOTS"))
if (is.na(cores)) cores=3
registerDoParallel(cores)
print(paste0("n. of cores is ",cores))
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files')
# Arguments:
city = 'GTA_V061_500m_2021'
yr = 2021
veg_type = 'DBF' #Maybe use Mixed forest instead?
## If area is too big (n of pixels > nrow_block) divide in blocks of nrow_block cells
nrow_block=2500
# Climate data folder
dir_clima = paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/2021') # climate data in /urbanVPRM_30m/driver_data/rap_goes/
## Define the path to the folder where outputs are saved
dir.create(paste0("outputs"), showWarnings = FALSE)
dir.create(paste0("outputs/",city), showWarnings = FALSE)
dir_out = paste0(city)
## Function to convert tif into a datatable..
tifdt_fun = function(raster,name){
dt = as.data.table(as.data.frame(raster, xy=T))
dt = cbind(1:ncell(raster), dt)
setnames(dt,c("Index","x","y",name))
setkey(dt,Index,x,y)
return(dt)
}
### LOAD DATA
## Land cover and ISA
## NEED TO CONVERT LC DATA TO SAME FORMAT AS NLCD DATA
LC = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/LandCover/MODIS_V061_LC_GTA_500m_2021.tif') # Land cover data in /urbanVPRM_30m/driver_data/lc_isa/
LC.dt = tifdt_fun(LC,"LandCover")
ISA_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/ISA/ISA_GTA_GMIS_Toronto_ACI_SOLRIS_500m_2021.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
ISA_dat<-resample(ISA_dat,LC) #for some reason x and y were offset by 1*10^-9 compared to LC raster, fix it by resampling
ISA.dt = tifdt_fun(ISA_dat,"ISA")
C4 = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/LandCover/C4_frac_GTA_500m_2021.tif') # C4 fraction
C4<-resample(C4,LC) #for some reason x and y were offset by 1*10^-9 compared to LC raster, fix it by resampling
C4.dt = tifdt_fun(C4,"C4")
## Merge LC and ISA
#LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index","x","y"))
#for some reason y is off by 1*10^-9 so it won't merge do it manually below:
LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index","x"))
LC_ISA.dt = merge(LC_ISA.dt,C4.dt,by=c("Index","x"))
LC_ISA.test<-LC_ISA.dt[,1:2]
LC_ISA.test$y<-LC_ISA.dt$y.x
LC_ISA.test$LandCover<-LC_ISA.dt$LandCover
LC_ISA.test$ISA<-LC_ISA.dt$ISA
LC_ISA.test$C4<-LC_ISA.dt$C4
LC_ISA.dt<-LC_ISA.test
npixel = as.numeric(nrow(LC_ISA.dt))
print(paste0("n. of pixels is ",npixel))
wtr_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/Impermeable_Surface/SOLRIS_aggregated_water_cover_GTA.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
wtr_dat<-resample(wtr_dat,LC) #for some reason x and y were offset by 1*10^-9 compared to LC raster, fix it by resampling
wtr.dt = tifdt_fun(wtr_dat,"wtr")
rm(ISA_dat,LC.dt,ISA.dt,C4,C4.dt,LC_ISA.test,wtr_dat)
print("LC, ISA & wtr loaded!")
greenup = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_greenup_2021.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
greenup <- crop(greenup,LC) #crop greenup to be the same size as LC data
# 85% EVI decrease
dormancy <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_Dormancy_2021.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
dormancy<- crop(dormancy,LC)
SoGS.dt = tifdt_fun(greenup,"SOS")
EoGS.dt = tifdt_fun(dormancy,"EOS")
GS.dt = merge(SoGS.dt,EoGS.dt,by=c("Index","x","y"))
rm(greenup,dormancy,SoGS.dt,EoGS.dt)
## Landsat EVI and LSWI
LS_VI.dt = fread('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GTA_V061_500m_2021/adjusted_evi_lswi_interpolated_modis_v061_qc_filtered_LSWI_filtered.csv', data.table=FALSE) #EVI/LSWI data in /urbanVPRM_30m/driver_data/evi_lswi/
## Load EVI data for a reference (Fully forested) pixel
# Borden Pixel = 98 # deciduous
# TP39 Pixel = 158 #deciduous or  109 #Mixed forest
# TPD Pixel = 153 #deciduous
# GTA Pixel = 3011 # deciduous
EVI_ref = LS_VI.dt[which(LS_VI.dt$Index == 3011),]
EVI_ref = EVI_ref$EVI_inter
minEVI_ref = min(EVI_ref)
EVI_ref = rep(EVI_ref,each=24)
### Load script that defines model parameters and calculates fluxes
source("UrbanVPRM_code/VPRM_parameters_equations.R") # Parameters/equations script found in # Phenology data in /urbanVPRM_30m/scripts/
print("Get scale factors and GEE and Respiration fluxes")
## First define time period datatable. It will give the first 2 columns of the output data table..
dates = data.frame(as.POSIXct(seq(as.POSIXct(paste0(yr,"-01-01 00:00"),format="%Y-%m-%d %H:%M",tz="Etc/GMT+5"),
as.POSIXlt(paste0(yr,"-12-31 23:00"),format="%Y-%m-%d %H:%M",tz="Etc/GMT+5"),by="hour")))
nhr = as.numeric(nrow(dates))
hoy = data.frame(1:nhr)
time.dt = cbind(dates,hoy)
colnames(time.dt) = c("Date","HoY")
rm(dates,hoy)
blocks = seq(1, npixel, by=nrow_block)
for(j in 1:length(blocks)) {
block = blocks[j]
cat(paste0("\n Working on block: ", block))
if(block != blocks[length(blocks)]){
lim = (block+nrow_block)
} else if (block == blocks[length(blocks)]) {
lim = npixel+1
}
#if(length(blocks)>1){
#  clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_",yr,"_hourly_block_",sprintf("%08i",as.numeric(block)),".rds"))
#} else {
clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_hourly_fixed.rds"))#v3_cropped.rds"))
#clima.dt = readRDS(paste0(dir_clima,"/rap_goes_GTA_500m_",yr,"_hourly.rds"))
#}
output.dt = foreach(i=block:(lim-1)) %do% {
#print(i)
### If EVI time series is made of NAs, skip to the next iteration/pixel
if(all(is.na(LS_VI.dt$EVI[LS_VI.dt$Index==i]))){
outputs = data.frame(Date=as.POSIXct(NA),HoY=NA_integer_,Index=i,GEE=NA_real_,
TScale=NA_real_,PScale=NA_real_,WScale=NA_real_,PAR=NA_real_,
Tair=NA_real_,Re=NA_real_,Ra=NA_real_,Rh=NA_real_,EVI_scale=NA_real_, stringsAsFactors=FALSE)
} else {
### Otherwise, extract input data for pixel i
## Get Land Cover class for pixel i
lc_which = which( LC_ISA.dt$Index==i )
lc_i = LC_lookup(as.numeric(LC_ISA.dt$LandCover[lc_which]),as.numeric(LC_ISA.dt$C4[lc_which]),veg_type )
## Get mean ISA percentage for pixel i (must be between 0 and 100%)
isa_i = as.numeric(LC_ISA.dt$ISA[lc_which]/100)
if(is.na(isa_i) | isa_i == 127 | isa_i < 0 | isa_i == 2.55){
isa_i = 0
} else if(isa_i > 1){
isa_i = 1
}
## Flag water pixels
if (lc_i == 'OTH'){wtr_i <- 1} else {wtr_i <- as.numeric(wtr.dt$wtr[lc_which])}
## Get hourly EVI and LSWI for pixel i
ls_which = which(LS_VI.dt$Index==i)
EVI_i = LS_VI.dt$EVI_inter[ls_which]
EVI_h = rep(EVI_i, each=24)
LSWI_i = LS_VI.dt$LSWI_inter[ls_which]
LSWI_h = rep(LSWI_i, each=24)
rm(EVI_i,LSWI_i)
## Get hourly air temperature and shortwave radiation for pixel i
clima_which = which(clima.dt$Index==i)
tair_i = clima.dt$tmpC[clima_which]
swrad_i = clima.dt[clima_which,c("HoY","swRad")]
### Finally get outputs for pixel i
outputs = getFluxes(time.dt,i,lc_i,isa_i,wtr_i,EVI_h,LSWI_h,tair_i,swrad_i)
}
print(i)
return(outputs)
}
output.dt = rbindlist(output.dt)
output.dt$Date = as.Date(output.dt$Date,format="%Y%m%d")
cat("\n Save data table with outputs..")
if(length(blocks)>1){
write.table(output.dt, paste0("GTA_V061_500m_2021/vprm_GMIS_Toronto_ACI_SOLRIS_ISA_500m_GTA_V061_2021_no_PScale_adjusted_Topt_Ra_URB_parameters_fixed_gapfilled_LSWI_filtered_block_",sprintf("%08i",as.numeric(block)),".csv"),
row.names = F, sep = ',')
#saveRDS(output.dt, paste0(dir_out,"/fluxes_",city,"_",yr,"_",veg_type,"_block_",
#                          sprintf("%08i",as.numeric(block)),".rds"))
} else {
write.table(output.dt, "GTA_V061_500m_2021/vprm_GMIS_Toronto_ACI_SOLRIS_ISA_500m_GTA_V061_2021_no_PScale_adjusted_Topt_Ra_URB_parameters_fixed_gapfilled_LSWI_filtered.csv",row.names = F,
sep = ',')
}
cat(paste0("\n Wrote block ", block,"!"))
rm(output.dt)
}
