library("parallel")
library("foreach")
library("doParallel")
library("ggplot2") #not needed for running just visualizing
## register cores for parallel processes on computing cluster
cores = as.numeric(Sys.getenv("NSLOTS"))
if (is.na(cores)) cores=1
registerDoParallel(cores)
print(paste0("n. of cores is ",cores))
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files')
# Arguments:
city = 'TPD_500m_V061_no_adjustments_2018'
yr = 2018
veg_type = 'DBF' #Maybe use Mixed forest instead?
## If area is too big (n of pixels > nrow_block) divide in blocks of nrow_block cells
nrow_block=2500 #15000
# Climate data folder we can use the updated version since the RAP and GOES scripts are the same between versions
dir_clima = paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_V061_500m_2018/2018') # climate data in /urbanVPRM_30m/driver_data/rap_goes/
dir.create(paste0("outputs/",city), showWarnings = FALSE)
dir_out = paste0(city)
## Function to convert tif into a datatable..
tifdt_fun = function(raster,name){
dt = as.data.table(as.data.frame(raster, xy=T))
dt = cbind(1:ncell(raster), dt)
setnames(dt,c("Index","x","y",name))
setkey(dt,Index,x,y)
return(dt)
}
### LOAD DATA
## Land cover and ISA
## NEED TO CONVERT LC DATA TO SAME FORMAT AS NLCD DATA
LC = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2018/LandCover/MODIS_LC_TPD_500m_V061_no_adjustments_2018.tif') # Land cover data in /urbanVPRM_30m/driver_data/lc_isa/
LC.dt = tifdt_fun(LC,"LandCover")
ISA_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2018/ISA/ISA_TPD_500m_2018.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
ISA_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2018/ISA/ISA_TPD_500m_2018.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
ISA.dt = tifdt_fun(ISA_dat,"ISA")
C4 = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2018/LandCover/C4_frac_TPD_500m_2018.tif') # C4 fraction
C4.dt = tifdt_fun(C4,"C4")
## Merge LC and ISA
#LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index","x","y"))
#for some reason x and y are off by 1*10^-9 so it won't merge do it manually below:
LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index"))
LC_ISA.dt = merge(LC_ISA.dt,C4.dt,by=c("Index"))
LC_ISA.test<-LC_ISA.dt[,1]
LC_ISA.test$x<-LC_ISA.dt$x.x
LC_ISA.test$y<-LC_ISA.dt$y.x
LC_ISA.test$LandCover<-LC_ISA.dt$LandCover
LC_ISA.test$ISA<-LC_ISA.dt$ISA
LC_ISA.test$C4<-LC_ISA.dt$C4
LC_ISA.dt<-LC_ISA.test
npixel = as.numeric(nrow(LC_ISA.dt))
print(paste0("n. of pixels is ",npixel))
wtr_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/Impermeable_Surface/SOLRIS_aggregated_water_cover_TPD.tif') # aggregated to MODIS resolution
wtr.dt = tifdt_fun(wtr_dat,"wtr")
rm(ISA_dat,LC.dt,ISA.dt,C4,C4.dt,LC_ISA.test,wtr_dat)
print("LC, ISA & wtr loaded!")
greenup = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_greenup_2018.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
greenup <- crop(greenup,LC) #crop greenup to be the same size as LC data
# 85% EVI decrease
dormancy <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_Dormancy_2018.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
dormancy<- crop(dormancy,LC)
SoGS.dt = tifdt_fun(greenup,"SOS")
EoGS.dt = tifdt_fun(dormancy,"EOS")
GS.dt = merge(SoGS.dt,EoGS.dt,by=c("Index","x","y"))
rm(greenup,dormancy,SoGS.dt,EoGS.dt)
## Landsat EVI and LSWI
LS_VI.dt = fread('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2018/adjusted_evi_lswi_interpolated_modis.csv', data.table=FALSE) #EVI/LSWI data in /urbanVPRM_30m/driver_data/evi_lswi/
## Load EVI data for a reference (Fully forested) pixel
# Borden Pixel = 98 # deciduous
# TP39 Pixel = 158 #deciduous or  109 #Mixed forest
# TPD Pixel = 153 #deciduous
# GTA Pixel = 3011 # deciduous
EVI_ref = LS_VI.dt[which(LS_VI.dt$Index == 153),]
EVI_ref = EVI_ref$EVI_inter
minEVI_ref = min(EVI_ref)
EVI_ref = rep(EVI_ref,each=24)
### Load script that defines model parameters and calculates fluxes
source("UrbanVPRM_code/VPRM_parameters_equations.R") # Parameters/equations script found in # Phenology data in /urbanVPRM_30m/scripts/
print("Get scale factors and GEE and Respiration fluxes")
## First define time period datatable. It will give the first 2 columns of the output data table..
dates = data.frame(as.POSIXct(seq(as.POSIXct(paste0(yr,"-01-01 00:00"),format="%Y-%m-%d %H:%M",tz="Etc/GMT+5"),
as.POSIXlt(paste0(yr,"-12-31 23:00"),format="%Y-%m-%d %H:%M",tz="Etc/GMT+5"),by="hour")))
nhr = as.numeric(nrow(dates))
hoy = data.frame(1:nhr)
time.dt = cbind(dates,hoy)
colnames(time.dt) = c("Date","HoY")
rm(dates,hoy)
blocks = seq(1, npixel, by=nrow_block)
for(j in 1:length(blocks)) {
block = blocks[j]
cat(paste0("\n Working on block: ", block))
if(block != blocks[length(blocks)]){
lim = (block+nrow_block)
} else if (block == blocks[length(blocks)]) {
lim = npixel+1
}
#if(length(blocks)>1){
#  clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_",yr,"_hourly_block_",sprintf("%08i",as.numeric(block)),".rds"))
#} else {
#clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_hourly.rds"))
clima.dt = readRDS(paste0(dir_clima,"/rap_goes_TPD_V061_500m_2018_hourly_fixed.rds"))
#}
output.dt = foreach(i=block:(lim-1)) %do% {
#print(i)
### If EVI time series is made of NAs, skip to the next iteration/pixel
if(all(is.na(LS_VI.dt$EVI[LS_VI.dt$Index==i]))){
outputs = data.frame(Date=as.POSIXct(NA),HoY=NA_integer_,Index=i,GEE=NA_real_,
TScale=NA_real_,PScale=NA_real_,WScale=NA_real_,PAR=NA_real_,
Tair=NA_real_,Re=NA_real_,Ra=NA_real_,Rh=NA_real_,EVI_scale=NA_real_, stringsAsFactors=FALSE)
} else {
### Otherwise, extract input data for pixel i
## Get Land Cover class for pixel i
lc_which = which( LC_ISA.dt$Index==i )
lc_i = LC_lookup(as.numeric(LC_ISA.dt$LandCover[lc_which]),as.numeric(LC_ISA.dt$C4[lc_which]),veg_type )
## Get mean ISA percentage for pixel i (must be between 0 and 100%)
isa_i = as.numeric(LC_ISA.dt$ISA[lc_which]/100)
if(is.na(isa_i) | isa_i == 127 | isa_i < 0 | isa_i == 2.55){
isa_i = 0
} else if(isa_i > 1){
isa_i = 1
}
## Flag water pixels
if (lc_i == 'OTH'){wtr_i <- 1} else {wtr_i <- as.numeric(wtr.dt$wtr[lc_which])}
## Get hourly EVI and LSWI for pixel i
ls_which = which(LS_VI.dt$Index==i)
EVI_i = LS_VI.dt$EVI_inter[ls_which]
EVI_h = rep(EVI_i, each=24)
LSWI_i = LS_VI.dt$LSWI_inter[ls_which]
LSWI_h = rep(LSWI_i, each=24)
rm(EVI_i,LSWI_i)
## Get hourly air temperature and shortwave radiation for pixel i
clima_which = which(clima.dt$Index==i)
tair_i = clima.dt$tmpC[clima_which]
swrad_i = clima.dt[clima_which,c("HoY","swRad")]
### Finally get outputs for pixel i
outputs = getFluxes(time.dt,i,lc_i,isa_i,wtr_i,EVI_h,LSWI_h,tair_i,swrad_i)
}
print(i)
return(outputs)
}
output.dt = rbindlist(output.dt)
output.dt$Date = as.Date(output.dt$Date,format="%Y%m%d")
cat("\n Save data table with outputs..")
if(length(blocks)>1){
write.table(output.dt, paste0(city,"/vprm_mixed_TPD_500m_V061_2018_no_adjustment_",sprintf("%08i",as.numeric(block)),".csv"),
row.names = F, sep = ',')
#saveRDS(output.dt, paste0(dir_out,"/fluxes_",city,"_",yr,"_",veg_type,"_block_",
#                          sprintf("%08i",as.numeric(block)),".rds"))
} else {
write.table(output.dt, "TPD_500m_V061_no_adjustments_2018/vprm_mixed_ISA_TPD_500m_V061_2018_no_adjustments.csv",row.names = F,
sep = ',')
}
cat(paste0("\n Wrote block ", block,"!"))
rm(output.dt)
}
# import packages
library("data.table")
library("raster")
library("sp")
library("rgdal")
library("shapefiles")
## Create Directories
setwd("C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files")
city = 'TPD_500m_V061_no_adjustments_2019'
print("Create directories for LC data")
dir.create(paste0(city),showWarnings = FALSE)
dir.create(paste0(city,"/LandCover"),showWarnings = FALSE)
dir.create(paste0(city,"/ISA"),showWarnings = FALSE)
## Define CRS of LANDSAT and NLCD data
LANDSAT_CRS = "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
NLCD_CRS = "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80
+towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
MODIS_CRS = '+proj=longlat +datum=WGS84 +no_defs'
#####  HERE ######
bound_box_0 = readOGR(dsn="E:/Research/UrbanVPRM/dataverse_files/TPD/shapefiles", layer='TPD_30m_BB_4km')
#bound_box_0 = readOGR(dsn="C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TP39_500m_2019/shapefiles", layer='TP39_30m_BB_4km') #TPD/shapefiles",layer='TPD_30m_BB_4km') # shapefile data in /urbanVPRM_30m/shapefiles/
#bound_box = spTransform(bound_box_0, LANDSAT_CRS)
bound_box_MODIS = spTransform(bound_box_0, '+proj=longlat +datum=WGS84 +no_defs')
## Import, reproject, and crop LC and ISA data
# Land Cover
LC_ON = raster("C:/Users/kitty/Documents/Research/SIF/SMUrF/data/MCD12Q1/MCD12Q1.061_LC_Type1_doy2019001_aid0001.tif")
LC_crop = crop(LC_ON, bound_box_MODIS)
# ISA ***NEED to decide on dataset used and figure out how to get it in the right format
ISA_ON = raster("C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/Impermeable_Surface/GMIS_Toronto_ACI_SOLRIS_2019_impervious_GTA.tif")#all_aggregated_impervious_63_TPD.tif") # Impervious data from https://www.mrlc.gov/data
#grid_ISA = projectRaster(ISA_ON,crs=MODIS_CRS)
ISA_ONcrop = crop(ISA_ON,bound_box_MODIS)
#See SMUrF code
C4_ON = raster("C:/Users/kitty/Documents/Research/SIF/SMUrF/data/ACI_C4_fraction_GTA_500m_2019.tif") # C3/C4 data from ACI aggregated to 500m res
C4_ONcrop = crop(C4_ON,bound_box_MODIS)
# Write Rasters
writeRaster(LC_crop,filename="C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/LandCover/MODIS_LC_TPD_500m_V061_no_adjustments_2019.tif",
overwrite=TRUE)
writeRaster(ISA_ONcrop,filename="C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/ISA/ISA_TPD_500m_2019.tif",
overwrite=TRUE)
writeRaster(C4_ONcrop,filename="C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/LandCover/C4_frac_TPD_500m_2019.tif",
overwrite=TRUE)
# import packages
library("data.table")
library("raster")
library("sp")
library("rgdal")
library("lubridate")
#MODIS:
LC_dat<-raster("C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/LandCover/MODIS_LC_TPD_500m_V061_no_adjustments_2019.tif")
#MODIS reflectance files
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/MODIS_reflectance/MODIS_V061_GTA_AppEEARS_2019') # landsat data in /urbanVPRM_30m/driver_data/landsat/
mod_files <- list.files(pattern = 'MOD09A1.061_sur_refl_b01')
yr<-2019
#QC values where red,NIR, and blue pass the quality test:
EVI_qc<-c(1073741824,1073954817,1075838976,1075838977,1075838979,1076051969,
1076625411,1077149697,1077411843,1119879171,1121976323,1123287043,
1123549187,1128267777,1130364929,1130364931,1131151363,1131675649,
1131937795,1132462083,1134559235,1135345667,1135869955,1136132099,
1811939331,1814036483,1814822915,1815347203,1815609347,1858076675,
1860173827,1861484547,1861746691,1866465283,1868562435,1869873155,
1870135299,1870659587,1872756739,1874067459,1874329603,1946157057,
1946370049,1948254209,1948254211,1948467201,1949040643,1949564929,
1949827075,1992294403,1994391555,1995702275,1995964419,2000683009,
2002780161,2002780163,2003566595,2004090881,2004303873,2004353027,
2004877315,2006974467,2007760899,2008285187,2008547331,2013265923,
2013478915,2015363075,2015576067,2016149507,2016673795,2016886787,
2016935939,2059403267,2061500419,2062811139,2063073283,2067791875,
2069889027,2070675459,2071199747,2071461891,2071986179,2074083331,
2074869763,2075394051,2075656195)
#QC values where NIR and SWIR pass the quality test:
LSWI_qc<-c(1073741824,1073741877,1073954817,1073954869,1075838976,1075838977,
1075838979,1075839029,1076051969,1076052021,1076625411,1077149697,
1077149749,1077362741,1077411843,1077411895,1119879171,1119879223,
1121976323,1121976375,1123287043,1123287095,1123549187,1128267777,
1128267829,1128480821,1130364929,1130364931,1130364981,1131151363,
1131675649,1131675701,1131937795,1131937847,1132462083,1132462135,
1132675127,1134559235,1134559287,1135345667,1135345719,1135869955,
1135870007,1136132099,1136132151)
for (i in 1:length(mod_files)){
## read in raster stack
mod_file_red <- crop(stack(mod_files[i]),LC_dat)
mod_file_NIR <-crop(stack(paste(substr(mod_files[i],1,23),"2",substr(mod_files[i],25,47),sep = "")),LC_dat)
mod_file_blue <-crop(stack(paste(substr(mod_files[i],1,23),"3",substr(mod_files[i],25,47),sep = "")),LC_dat)
mod_file_SWIR <-crop(stack(paste(substr(mod_files[i],1,23),"7",substr(mod_files[i],25,47),sep = "")),LC_dat)
mod_file_QC <- crop(stack(paste(substr(mod_files[i],1,21),"qc_500m",substr(mod_files[i],25,47),sep = "")),LC_dat)
file <- stack(mod_file_red,mod_file_NIR,mod_file_blue,mod_file_SWIR,mod_file_QC)
## apply scale factors for reflectance data in the bands needed for EVI/LSWI calculation (only for V6)
#file[[1]] <- file[[1]] * 0.0001
#file[[2]] <- file[[2]] * 0.0001
#file[[3]] <- file[[3]] * 0.0001
#file[[4]] <- file[[4]] * 0.0001
## only keep clear observations determined from CFmask (pixel QA band 11 codes 322, 386, 834, 898, or 1346)
#clear_code <- c(322, 386, 834, 898, 1346)
#bad_pixels <- which(!(values(file[[11]]) %in% clear_code))
#values(file[[2]])[bad_pixels] <- NA
#values(file[[4]])[bad_pixels] <- NA
#values(file[[5]])[bad_pixels] <- NA
#values(file[[6]])[bad_pixels] <- NA
EVI_bad_pixels <- which(!(values(file[[5]])) %in% EVI_qc)
LSWI_bad_pixels <- which(!(values(file[[5]])) %in% LSWI_qc)
file[[1]][EVI_bad_pixels]<-NA
#file[[2]][EVI_bad_pixels]<-NA
file[[3]][EVI_bad_pixels]<-NA
#file[[2]][LSWI_bad_pixels]<-NA
file[[4]][LSWI_bad_pixels]<-NA
### calculate EVI
file[[6]] <- 2.5 * ((file[[2]] - file[[1]]) / (file[[2]] + 6 * file[[1]] - 7.5 * file[[3]] + 1))
#file[[5]][abs(file[[5]])>1]<-NA
## calculate LSWI
file[[7]] <- (file[[2]] - file[[4]]) / (file[[2]] + file[[4]])
#Replace eroneous values with NA
#file[[6]][abs(file[[6]])>1]<-NA
## convert raster data to data.table and assign Day of Year values
## EVI
EVI.dt = as.data.table(as.data.frame(file[[6]], xy=T))
EVI.dt = cbind(1:ncell(file[[6]]), EVI.dt)
setnames(EVI.dt,c("Index","x","y", "EVI"))
setkey(EVI.dt,Index,x,y)
## LSWI
LSWI.dt = as.data.table(as.data.frame(file[[7]], xy=T))
LSWI.dt = cbind(1:ncell(file[[7]]), LSWI.dt)
#LSWI.dt$DOY = yday(ymd(paste0('2018',substr((names(file))[1],3,6))))
#The line above was trying to use the first column of the file instead of the
# file name (replacement bellow uses file name)
#TPD:
#LSWI.dt$DOY = yday(ymd(paste0('2018',substr(ls8[i],12,15))))
#Borden:
if (as.numeric((substr(mod_files[i],29,32)))<yr){
LSWI.dt$DOY = as.numeric((substr(mod_files[i],33,35)))-365+1
}else if (as.numeric((substr(mod_files[i],29,32)))>yr){
LSWI.dt$DOY = as.numeric((substr(mod_files[i],33,35)))+365
}else{
LSWI.dt$DOY = as.numeric((substr(mod_files[i],33,35)))
}
#LSWI.dt$DOY = as.numeric((substr(mod_files[i],33,35)))
setnames(LSWI.dt,c("Index","x","y", "LSWI","DOY"))
setkey(LSWI.dt,Index,x,y)
## save a data.table for each image
assign(paste0('EVI_LSWI',i,'.dt'), merge(EVI.dt,LSWI.dt,by=c("Index","x","y")))
}
EVI_LSWI.dt <- rbind(EVI_LSWI1.dt,EVI_LSWI2.dt,EVI_LSWI3.dt,EVI_LSWI4.dt,EVI_LSWI5.dt,EVI_LSWI6.dt,
EVI_LSWI7.dt,EVI_LSWI8.dt,EVI_LSWI9.dt,EVI_LSWI10.dt,EVI_LSWI11.dt, EVI_LSWI12.dt,
EVI_LSWI13.dt,EVI_LSWI14.dt,EVI_LSWI15.dt,EVI_LSWI16.dt,EVI_LSWI17.dt,EVI_LSWI18.dt,
EVI_LSWI19.dt,EVI_LSWI20.dt,EVI_LSWI21.dt,EVI_LSWI22.dt,EVI_LSWI23.dt,EVI_LSWI24.dt,
EVI_LSWI25.dt,EVI_LSWI26.dt,EVI_LSWI27.dt,EVI_LSWI28.dt,EVI_LSWI29.dt,EVI_LSWI30.dt,
EVI_LSWI31.dt,EVI_LSWI32.dt,EVI_LSWI33.dt,EVI_LSWI34.dt,EVI_LSWI35.dt,EVI_LSWI36.dt,
EVI_LSWI37.dt,EVI_LSWI38.dt,EVI_LSWI39.dt,EVI_LSWI40.dt,EVI_LSWI41.dt,EVI_LSWI42.dt,
EVI_LSWI43.dt,EVI_LSWI44.dt,EVI_LSWI45.dt,EVI_LSWI46.dt,EVI_LSWI47.dt,EVI_LSWI48.dt,
EVI_LSWI49.dt)
## order by DOY
EVI_LSWI.dt <- EVI_LSWI.dt[order(EVI_LSWI.dt$DOY),]
## convert to dataframe
EVI_LSWI.df <- as.data.frame(EVI_LSWI.dt)
## There are a few erroneous values e.g. EVI = 2.5. These are omitted from the dataset
EVI_LSWI.df[which(EVI_LSWI.df$EVI > 1),'EVI'] <- NA
EVI_LSWI.df[which(EVI_LSWI.df$EVI < -1),'EVI'] <- NA
EVI_LSWI.df[which(EVI_LSWI.df$LSWI > 1),'LSWI'] <- NA
EVI_LSWI.df[which(EVI_LSWI.df$LSWI < -1),'LSWI'] <- NA
## Set up new dataframe for EVI/LSWI Interpolation
npixel <- length(unique(EVI_LSWI.df$Index))
inter_evi_lswi <- as.data.frame(matrix(ncol = 2, nrow = npixel*378))
colnames(inter_evi_lswi) <- c('Index', 'DOY')
inter_evi_lswi[,1] <- rep(seq(1,npixel,1), 378)
inter_evi_lswi <- inter_evi_lswi[order(inter_evi_lswi[,1]),]
inter_evi_lswi[,2] <- rep(seq(-3,374,1), npixel)
inter_evi_lswi <- merge(inter_evi_lswi, EVI_LSWI.df[,c('Index', 'EVI', 'LSWI', 'DOY')], by = c('Index', 'DOY'), all = TRUE)
inter_evi_lswi  <- inter_evi_lswi[order(inter_evi_lswi[,'Index'],inter_evi_lswi [,'DOY']),]
# add coordinates
x <- as.data.frame(tapply(EVI_LSWI.df$x, EVI_LSWI.df$Index, mean, na.rm = T))
y <- as.data.frame(tapply(EVI_LSWI.df$y, EVI_LSWI.df$Index, mean, na.rm = T))
xy <- cbind(as.numeric(rownames(x)), x, y)
colnames(xy) <- c('Index', 'x', 'y')
inter_evi_lswi <- merge(inter_evi_lswi, xy, by = 'Index', all = TRUE)
inter_evi_lswi <- inter_evi_lswi[,c('Index', 'DOY', 'x', 'y', 'EVI', 'LSWI')]
# Interpolate daily EVI values for each pixel
inter_evi_lswi$EVI_inter <- NA
for(i in unique(inter_evi_lswi$Index)){
if(is.finite(mean(inter_evi_lswi[which(inter_evi_lswi$Index == i),'EVI'], na.rm = T)) & length(inter_evi_lswi[which(inter_evi_lswi$Index == i & is.finite(inter_evi_lswi$EVI)),'EVI']) > 10){
pix <- inter_evi_lswi[which(inter_evi_lswi$Index == i),]
spl <- with(pix[!is.na(pix$EVI),],smooth.spline(DOY,EVI, spar = .25))
inter_evi_lswi[which(inter_evi_lswi$Index == i),'EVI_inter'] <- predict(spl, c(-3:374))$y
} else {inter_evi_lswi[which(inter_evi_lswi$Index == i),'EVI_inter'] <- NA}
print(round(i/npixel*100, 1))
}
# Interpolate daily LSWI values for each pixel
inter_evi_lswi$LSWI_inter <- NA
for(i in unique(inter_evi_lswi$Index)){
if(is.finite(mean(inter_evi_lswi[which(inter_evi_lswi$Index == i),'LSWI'], na.rm = T)) & length(inter_evi_lswi[which(inter_evi_lswi$Index == i & is.finite(inter_evi_lswi$LSWI)),'LSWI']) > 10){
pix <- inter_evi_lswi[which(inter_evi_lswi$Index == i),]
spl <- with(pix[!is.na(pix$LSWI),],smooth.spline(DOY,LSWI, spar = .25))
inter_evi_lswi[which(inter_evi_lswi$Index == i),'LSWI_inter'] <- predict(spl, c(-3:374))$y
} else {inter_evi_lswi[which(inter_evi_lswi$Index == i),'LSWI_inter'] <- NA}
print(round(i/npixel*100, 1))
}
inter_evi_lswi.dt<-as.data.table(inter_evi_lswi)
inter_evi_lswi.dt<-inter_evi_lswi.dt[inter_evi_lswi.dt$DOY>0 & inter_evi_lswi.dt$DOY<366] #select only data that falls within the year
inter_evi_lswi.df<-as.data.frame(inter_evi_lswi.dt)#convert back to dataframe
write.table(inter_evi_lswi.df,'C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/adjusted_evi_lswi_interpolated_modis.csv',row.names = F,
sep=',')
memory.limit(size=5e8)
## Load libraries
library("data.table")
library("raster")
library("parallel")
library("foreach")
library("doParallel")
library("ggplot2") #not needed for running just visualizing
## register cores for parallel processes on computing cluster
cores = as.numeric(Sys.getenv("NSLOTS"))
if (is.na(cores)) cores=1
registerDoParallel(cores)
print(paste0("n. of cores is ",cores))
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files')
# Arguments:
city = 'TPD_500m_V061_no_adjustments_2019'
yr = 2019
veg_type = 'DBF' #Maybe use Mixed forest instead?
## If area is too big (n of pixels > nrow_block) divide in blocks of nrow_block cells
nrow_block=2500 #15000
# Climate data folder we can use the updated version since the RAP and GOES scripts are the same between versions
dir_clima = paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_V061_500m_2019/2019') # climate data in /urbanVPRM_30m/driver_data/rap_goes/
dir.create(paste0("outputs/",city), showWarnings = FALSE)
dir_out = paste0(city)
## Function to convert tif into a datatable..
tifdt_fun = function(raster,name){
dt = as.data.table(as.data.frame(raster, xy=T))
dt = cbind(1:ncell(raster), dt)
setnames(dt,c("Index","x","y",name))
setkey(dt,Index,x,y)
return(dt)
}
### LOAD DATA
## Land cover and ISA
## NEED TO CONVERT LC DATA TO SAME FORMAT AS NLCD DATA
LC = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/LandCover/MODIS_LC_TPD_500m_V061_no_adjustments_2019.tif') # Land cover data in /urbanVPRM_30m/driver_data/lc_isa/
LC.dt = tifdt_fun(LC,"LandCover")
ISA_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/ISA/ISA_TPD_500m_2019.tif') # Impervious data in /urbanVPRM_30m/driver_data/lc_isa/
ISA.dt = tifdt_fun(ISA_dat,"ISA")
C4 = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/LandCover/C4_frac_TPD_500m_2019.tif') # C4 fraction
C4.dt = tifdt_fun(C4,"C4")
## Merge LC and ISA
#LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index","x","y"))
#for some reason x and y are off by 1*10^-9 so it won't merge do it manually below:
LC_ISA.dt = merge(LC.dt,ISA.dt,by=c("Index"))
LC_ISA.dt = merge(LC_ISA.dt,C4.dt,by=c("Index"))
LC_ISA.test<-LC_ISA.dt[,1]
LC_ISA.test$x<-LC_ISA.dt$x.x
LC_ISA.test$y<-LC_ISA.dt$y.x
LC_ISA.test$LandCover<-LC_ISA.dt$LandCover
LC_ISA.test$ISA<-LC_ISA.dt$ISA
LC_ISA.test$C4<-LC_ISA.dt$C4
LC_ISA.dt<-LC_ISA.test
npixel = as.numeric(nrow(LC_ISA.dt))
print(paste0("n. of pixels is ",npixel))
wtr_dat = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/Impermeable_Surface/SOLRIS_aggregated_water_cover_TPD.tif') # aggregated to MODIS resolution
wtr.dt = tifdt_fun(wtr_dat,"wtr")
rm(ISA_dat,LC.dt,ISA.dt,C4,C4.dt,LC_ISA.test,wtr_dat)
print("LC, ISA & wtr loaded!")
greenup = raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_greenup_2019.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
greenup <- crop(greenup,LC) #crop greenup to be the same size as LC data
# 85% EVI decrease
dormancy <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/MODIS_phenology/MODIS_V061_avg_Dormancy_2019.tif') # Phenology data in /urbanVPRM_30m/driver_data/ms_lsp/
dormancy<- crop(dormancy,LC)
SoGS.dt = tifdt_fun(greenup,"SOS")
EoGS.dt = tifdt_fun(dormancy,"EOS")
GS.dt = merge(SoGS.dt,EoGS.dt,by=c("Index","x","y"))
rm(greenup,dormancy,SoGS.dt,EoGS.dt)
## Landsat EVI and LSWI
LS_VI.dt = fread('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD_500m_V061_no_adjustments_2019/adjusted_evi_lswi_interpolated_modis.csv', data.table=FALSE) #EVI/LSWI data in /urbanVPRM_30m/driver_data/evi_lswi/
## Load EVI data for a reference (Fully forested) pixel
# Borden Pixel = 98 # deciduous
# TP39 Pixel = 158 #deciduous or  109 #Mixed forest
# TPD Pixel = 153 #deciduous
# GTA Pixel = 3011 # deciduous
EVI_ref = LS_VI.dt[which(LS_VI.dt$Index == 153),]
EVI_ref = EVI_ref$EVI_inter
minEVI_ref = min(EVI_ref)
EVI_ref = rep(EVI_ref,each=24)
### Load script that defines model parameters and calculates fluxes
source("UrbanVPRM_code/VPRM_parameters_equations.R") # Parameters/equations script found in # Phenology data in /urbanVPRM_30m/scripts/
print("Get scale factors and GEE and Respiration fluxes")
## First define time period datatable. It will give the first 2 columns of the output data table..
dates = data.frame(as.POSIXct(seq(as.POSIXct(paste0(yr,"-01-01 00:00"),format="%Y-%m-%d %H:%M",tz="Etc/GMT+5"),
as.POSIXlt(paste0(yr,"-12-31 23:00"),format="%Y-%m-%d %H:%M",tz="Etc/GMT+5"),by="hour")))
nhr = as.numeric(nrow(dates))
hoy = data.frame(1:nhr)
time.dt = cbind(dates,hoy)
colnames(time.dt) = c("Date","HoY")
rm(dates,hoy)
blocks = seq(1, npixel, by=nrow_block)
for(j in 1:length(blocks)) {
block = blocks[j]
cat(paste0("\n Working on block: ", block))
if(block != blocks[length(blocks)]){
lim = (block+nrow_block)
} else if (block == blocks[length(blocks)]) {
lim = npixel+1
}
#if(length(blocks)>1){
#  clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_",yr,"_hourly_block_",sprintf("%08i",as.numeric(block)),".rds"))
#} else {
#clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_hourly.rds"))
clima.dt = readRDS(paste0(dir_clima,"/rap_goes_TPD_V061_500m_2019_hourly_fixed.rds"))
#}
output.dt = foreach(i=block:(lim-1)) %do% {
#print(i)
### If EVI time series is made of NAs, skip to the next iteration/pixel
if(all(is.na(LS_VI.dt$EVI[LS_VI.dt$Index==i]))){
outputs = data.frame(Date=as.POSIXct(NA),HoY=NA_integer_,Index=i,GEE=NA_real_,
TScale=NA_real_,PScale=NA_real_,WScale=NA_real_,PAR=NA_real_,
Tair=NA_real_,Re=NA_real_,Ra=NA_real_,Rh=NA_real_,EVI_scale=NA_real_, stringsAsFactors=FALSE)
} else {
### Otherwise, extract input data for pixel i
## Get Land Cover class for pixel i
lc_which = which( LC_ISA.dt$Index==i )
lc_i = LC_lookup(as.numeric(LC_ISA.dt$LandCover[lc_which]),as.numeric(LC_ISA.dt$C4[lc_which]),veg_type )
## Get mean ISA percentage for pixel i (must be between 0 and 100%)
isa_i = as.numeric(LC_ISA.dt$ISA[lc_which]/100)
if(is.na(isa_i) | isa_i == 127 | isa_i < 0 | isa_i == 2.55){
isa_i = 0
} else if(isa_i > 1){
isa_i = 1
}
## Flag water pixels
if (lc_i == 'OTH'){wtr_i <- 1} else {wtr_i <- as.numeric(wtr.dt$wtr[lc_which])}
## Get hourly EVI and LSWI for pixel i
ls_which = which(LS_VI.dt$Index==i)
EVI_i = LS_VI.dt$EVI_inter[ls_which]
EVI_h = rep(EVI_i, each=24)
LSWI_i = LS_VI.dt$LSWI_inter[ls_which]
LSWI_h = rep(LSWI_i, each=24)
rm(EVI_i,LSWI_i)
## Get hourly air temperature and shortwave radiation for pixel i
clima_which = which(clima.dt$Index==i)
tair_i = clima.dt$tmpC[clima_which]
swrad_i = clima.dt[clima_which,c("HoY","swRad")]
### Finally get outputs for pixel i
outputs = getFluxes(time.dt,i,lc_i,isa_i,wtr_i,EVI_h,LSWI_h,tair_i,swrad_i)
}
print(i)
return(outputs)
}
output.dt = rbindlist(output.dt)
output.dt$Date = as.Date(output.dt$Date,format="%Y%m%d")
cat("\n Save data table with outputs..")
if(length(blocks)>1){
write.table(output.dt, paste0(city,"/vprm_mixed_TPD_500m_V061_2019_no_adjustment_",sprintf("%08i",as.numeric(block)),".csv"),
row.names = F, sep = ',')
#saveRDS(output.dt, paste0(dir_out,"/fluxes_",city,"_",yr,"_",veg_type,"_block_",
#                          sprintf("%08i",as.numeric(block)),".rds"))
} else {
write.table(output.dt, "TPD_500m_V061_no_adjustments_2019/vprm_mixed_ISA_TPD_500m_V061_2019_no_adjustments.csv",row.names = F,
sep = ',')
}
cat(paste0("\n Wrote block ", block,"!"))
rm(output.dt)
}
