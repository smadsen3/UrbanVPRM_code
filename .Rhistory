}
inter_evi_lswi.dt<-as.data.table(inter_evi_lswi)
inter_evi_lswi.dt<-inter_evi_lswi.dt[inter_evi_lswi.dt$DOY>0 & inter_evi_lswi.dt$DOY<366] #select only data that falls within the year
inter_evi_lswi.df<-as.data.frame(inter_evi_lswi.dt)#convert back to dataframe
write.table(inter_evi_lswi.df,'C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TP39_500m_V061_adjusted_R_2018/adjusted_evi_lswi_interpolated_modis.csv',row.names = F,
sep=',')
# import packages
library(StreamMetabolism)
library(rgdal)
library(zoo)
library(purrr)
library(data.table)
library(ncdf4)
library(raster)
library(sp)
library(parallel)
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/')
xmin = -80.3574-4/240
xmax = -80.3574+4/240
ymin =  42.7102-4/240
ymax =  42.7102+4/240
city = 'TP39_500m_V061_adjusted_R_2018'
yr = 2018
# Set/Create file directories
inDIR <- paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2018/origTIFF/')
dir.create(paste0(city),showWarnings = FALSE)
dir.create(paste0(city,'/',yr),showWarnings = FALSE)
outDIR <- paste0(city,'/',yr)
rapDIR <- paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2018/RAPgrib/subfolder/')
eraDIR<- paste0('E:/Research/SMUrF/data/ERA5/2018/')
# Time file
times <- fread(paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2018/times',yr,'.csv')) # time data found in /urbanVPRM_30m/driver_data/times/
setkey(times,chr)
# CRS list
LANDSAT_CRS = "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
RAP_CRS = "+proj=lcc +lat_1=25 +lat_2=25 +lat_0=25 +lon_0=265 +x_0=0 +y_0=0 +a=6371229 +b=6371229 +units=m +no_defs"
MODIS_CRS = "+proj=longlat +datum=WGS84 +no_defs"
# Import raster of study domain and convert to SpatialPoints object for resampling
#ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD/landsat/landsat8/ls_TPD2018_0203_8_2km_all_bands.tif') # landsat data in /urbanVPRM_30m/driver_data/landsat/
md <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TP39_500m_V061_adjusted_R_2018/LandCover/MODIS_LC_TP39_500m_V061_adjusted_R_2018.tif')
values(md) <- 1
#values(ls) <- 1
md.spdf <- as(md, 'SpatialPointsDataFrame')
# Create slightly larger bounding box to crop to (avoids dropped pixels at edge when reprojecting / resampling)
bbox <- extent(xmin,xmax,ymin,ymax)
buff=0.05
bbox.extra <- extent(xmin - buff, xmax + buff, ymin - buff, ymax + buff)
# Create extended bounding box raster in Landsat projection
gridXY = as(raster::extent(bbox.extra), "SpatialPolygons")
proj4string(gridXY) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
dom.bbextra <- as(gridXY,'SpatialPolygonsDataFrame')
RAP.XY <- projectRaster(raster(gridXY),crs=MODIS_CRS)
# Obtain correct extent for RAP files from one of the raw RAP grib2 data files
rl.grb <- list.files(path=rapDIR,recursive='TRUE',pattern='.grb2') # rap data downloaded from https://www.ncei.noaa.gov/data/rapid-refresh/access/historical/analysis/
RAP_EXT <- extent(raster(paste0(rapDIR,rl.grb[1]))) #DOESN'T UNDERSTAND PROJECTION...?
# Create file list of converted RAP .tif data files to crop and project
rl <- list.files(path=inDIR,pattern='rap') #need to create tif files for rap data
# function to extract RAP data for study domain
rap2modis <- function(dir,file,domain){
print(paste0("Processing file ",file))
m <- copy(md)
rs <- raster(paste0(dir,file))
extent(rs) = RAP_EXT
rs <- projectRaster(rs, RAP.XY)
rap.crop <- crop(rs,extent(RAP.XY))
vals <- extract(rap.crop,md.spdf)
values(m) <- vals
y <- list(m)
return(y)
}
# run function
outlist <- mcmapply(rap2modis, dir=inDIR, file=rl, domain=city, mc.cores=1)
xyvals<-as.data.table(as.data.frame(md.spdf))
colnames(xyvals)[1]<-"tempK"
xyvals$tempK=xyvals$tempK*NA
# Compile all cropped and reprojected hourly rasters into single "long" data.table
cnames <- paste0(substr(rl,9,16), substr(rl,18,19))
st <- stack(outlist)
dt <- as.data.table(as.data.frame(st,xy=T))
setnames(dt,c('x','y',cnames))
dm <- melt.data.table(dt,id.vars=c('x','y'),variable.name='datetime',value.name='tempK',variable.factor=F)
cat("\n done 1!")
dm <- dm[!is.na(tempK)]
print("done 2!")
setkey(dm,datetime)
td <- times[,.(chr,datetime)]
td[,datetime:=as.character(datetime)]
setkey(td,chr)
missing_dates<-setdiff(as.numeric(td$datetime),as.numeric(dm$datetime))
#test_dm<-dm[td,on='datetime']
test_dm<-dm
if (length(missing_dates)>0){
for (d in missing_dates){
temp_dm<-xyvals
temp_dm$datetime<-d
temp_dm<-temp_dm[,c('x','y','datetime','tempK')]
test_dm<-rbindlist(list(test_dm,temp_dm))
#print(d)
}
}
setkey(test_dm,datetime)
test_dm <- td[test_dm, on='datetime']
# Create file list of ERA5 .nc data files to crop and project
eral <- list(list.files(path=eraDIR,pattern='era5_2T')) #need to create tif files for rap data
# function to extract ERA5 data for study domain
era2modis <- function(dir,file,datetime,domain){
yr<-substr(datetime,1,4)
mon<-substr(datetime,5,6)
da <- substr(datetime,7,8)
hr <- substr(datetime,9,10)
print(paste0("Processing ",datetime))
ERAstr<-paste0('X',yr,'.',mon,'.',da,'.',hr,'.00.00')
fl<-file[grep(paste0(yr,mon,'.nc'),file)]
ERArs <- raster::stack(paste0(dir,fl))
#ERAnm <- names(ERArs)
ERArs <- raster::subset(ERArs, ERAstr)
#rs <- raster(paste0(dir,file))
#extent(rs) = RAP_EXT
m <- copy(md)
ERArs <- projectRaster(ERArs, RAP.XY)
era.crop <- crop(ERArs,extent(RAP.XY))
vals <- extract(era.crop,md.spdf)
values(m) <- vals
y <- list(m)
return(y)
}
ERAoutlist <- mcmapply(era2modis, dir=eraDIR, file=eral, datetime=missing_dates, domain=city, mc.cores=1)
#if no missing dates run this line:
dm <- td[dm, on = 'datetime']
# Save in RDS binary format to preserve space
saveRDS(dm, paste0(outDIR,'/rap_',city,'.rds'))
cat("\n Done 3!")
#replace any remaining values outside of the range with the minimum and maximum of the range
dm$sw_test[dm$sw_inter < min(dm$swrad,na.rm=TRUE) & is.na(dm$sw_test)] <-0
dm$sw_test[dm$sw_inter > max(dm$swrad,na.rm=TRUE) & is.na(dm$sw_test)] <- max(dm$swrad,na.rm=TRUE)
library(raster)
library(dplyr)
library(ncdf4)
library(data.table)
library(ggplot2)
library(parallel)
library(StreamMetabolism) #for sunrise/sunset times
library(lubridate) #for converting date formats
library(zoo)
xmin = -80.3574-4/240
xmax = -80.3574+4/240
ymin =  42.7102-4/240
ymax =  42.7102+4/240
city = "TP39_500m_V061_adjusted_R_2018"
# Create slightly larger bounding box to crop to (avoids dropped pixels at edge when reprojecting / resampling)
bbox <- extent(xmin,xmax,ymin,ymax)
buff=0.05
bbox.extra <- extent(xmin - buff, xmax + buff, ymin - buff, ymax + buff)
yr = 2018
GOES_CRS = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 "
# Create extended bounding box raster in GOES projection
gridXY = as(raster::extent(bbox.extra), "SpatialPolygons")
proj4string(gridXY) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
GOES.XY <- projectRaster(raster(gridXY),crs=GOES_CRS)
inDIR <-'C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GOES/2018/origTIFF/'
rl <- list.files(path=inDIR,pattern='GOES') # GOES data downloaded from ftp://eftp.ifremer.fr/cersat-rt/project/osi-saf/data/radflux/
times <- fread(paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2018/times',yr,'.csv')) # times data in /urbanVPRM_30m/driver_data/times/
GOES_raster<- function(dir,dt){
name_list<-NULL
file<-rl[grep(as.character(dt),rl)]
if(file.exists(paste0(dir,file))){
print(paste0("Processing file ", file))
rs <- raster(paste0(dir,file),varname = 'ssi')
rs_c <- raster(paste0(dir,file),varname = 'ssi_confidence_level')
goes.crop <- crop(rs,bbox.extra)
goes_QF <-copy(goes.crop)
goes_QF[goes_QF<3]<-NA #remove any data with confidence level less than acceptable
#goes_proj <- resample(goes_3,GOES.XY)
#goes_stk<-stack(goes.crop,goes_3)
#names(goes_stk)<-c(ssi,ssi_QC)
names(goes_QF)<-substr(file,1,10)
}else{
print(paste0("Accounting for missing file ", dt))
rs <- raster(paste0(dir,rl[1]),varname = 'ssi')
goes.crop <- crop(rs,bbox.extra)
goes_QF <-copy(goes.crop)
goes_QF<-goes_QF*NA
names(goes_QF)<-as.character(dt)
}
return(goes_QF)
}
outlist <- mcmapply(GOES_raster, dir=inDIR, dt=times$datetime, mc.cores=1)
names(outlist)<-as.character(times$datetime)
#names(GOES.proj)<-substr(rl[idx_1],1,10)
st<-stack(outlist)
#cnames <-names(st)
#cnames[1] <-"X2019043023"
#names(st)<-cnames
cnames<-names(outlist)
dt<-as.data.table(as.data.frame(st,xy=T))
setnames(dt,c('x','y',cnames))
dt <-setDT(dt)
dm <- melt.data.table(dt,id.vars=c('x','y'),variable.name='datetime',value.name='swrad',variable.factor=F)
dm[,datetime:=as.character(datetime)][,swrad:=as.numeric(swrad)]
setkey(dm,x,y,datetime)
centX <- mean(xmin-buff,xmax+buff)
centY <- mean(ymin-buff,ymax+buff)
#
sun.rise <- function(x){
y <- sunrise.set(centY,centX,paste(substr(x,1,4),substr(x,5,6),substr(x,7,8),sep='/'),timezone='UTC')[1]
return(y)
}
sun.set <- function(x){
y <- sunrise.set(centY,centX,paste(substr(x,1,4),substr(x,5,6),substr(x,7,8),sep='/'),timezone='UTC')[2]
return(y)
}
#Deal with missing night time data
sunrise <- melt.data.table(as.data.table(lapply(times$datetime,sun.rise)),variable.name = 'date', value.name='posTime')
library(raster)
library(dplyr)
library(ncdf4)
library(data.table)
library(ggplot2)
library(parallel)
library(StreamMetabolism) #for sunrise/sunset times
library(lubridate) #for converting date formats
library(zoo)
# define study domain, city and year
xmin = -79.9333-4/240
xmax = -79.9333+4/240
ymin = 44.3167-4/240
ymax = 44.3167+4/240
city = 'Borden_500m_V061_adjusted_R_2018'
# Create slightly larger bounding box to crop to (avoids dropped pixels at edge when reprojecting / resampling)
bbox <- extent(xmin,xmax,ymin,ymax)
buff=0.05
bbox.extra <- extent(xmin - buff, xmax + buff, ymin - buff, ymax + buff)
yr = 2018
GOES_CRS = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 "
# Create extended bounding box raster in GOES projection
gridXY = as(raster::extent(bbox.extra), "SpatialPolygons")
proj4string(gridXY) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
GOES.XY <- projectRaster(raster(gridXY),crs=GOES_CRS)
GOES.XY
inDIR <-'C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GOES/2018/origTIFF/'
rl <- list.files(path=inDIR,pattern='GOES') # GOES data downloaded from ftp://eftp.ifremer.fr/cersat-rt/project/osi-saf/data/radflux/
times <- fread(paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2018/times',yr,'.csv')) # times data in /urbanVPRM_30m/driver_data/times/
GOES_raster<- function(dir,dt){
name_list<-NULL
file<-rl[grep(as.character(dt),rl)]
if(file.exists(paste0(dir,file))){
print(paste0("Processing file ", file))
rs <- raster(paste0(dir,file),varname = 'ssi')
rs_c <- raster(paste0(dir,file),varname = 'ssi_confidence_level')
goes.crop <- crop(rs,bbox.extra)
goes_QF <-copy(goes.crop)
goes_QF[goes_QF<3]<-NA #remove any data with confidence level less than acceptable
#goes_proj <- resample(goes_3,GOES.XY)
#goes_stk<-stack(goes.crop,goes_3)
#names(goes_stk)<-c(ssi,ssi_QC)
names(goes_QF)<-substr(file,1,10)
}else{
print(paste0("Accounting for missing file ", dt))
rs <- raster(paste0(dir,rl[1]),varname = 'ssi')
goes.crop <- crop(rs,bbox.extra)
goes_QF <-copy(goes.crop)
goes_QF<-goes_QF*NA
names(goes_QF)<-as.character(dt)
}
return(goes_QF)
}
outlist <- mcmapply(GOES_raster, dir=inDIR, dt=times$datetime, mc.cores=1)
times$datetime
times$datetime[1000]
times$datetime[10000]
times$datetime[5000]
outlist <- mcmapply(GOES_raster, dir=inDIR, dt=times$datetime[5000], mc.cores=1)
outlist
names(outlist)<-as.character(times$datetime)
names(outlist)<-as.character(times$datetime[5000])
#names(GOES.proj)<-substr(rl[idx_1],1,10)
st<-stack(outlist)
#cnames <-names(st)
#cnames[1] <-"X2019043023"
#names(st)<-cnames
cnames<-names(outlist)
dt<-as.data.table(as.data.frame(st,xy=T))
setnames(dt,c('x','y',cnames))
dt <-setDT(dt)
dm <- melt.data.table(dt,id.vars=c('x','y'),variable.name='datetime',value.name='swrad',variable.factor=F)
dm[,datetime:=as.character(datetime)][,swrad:=as.numeric(swrad)]
setkey(dm,x,y,datetime)
st
dm
centX <- mean(xmin-buff,xmax+buff)
centY <- mean(ymin-buff,ymax+buff)
#
sun.rise <- function(x){
y <- sunrise.set(centY,centX,paste(substr(x,1,4),substr(x,5,6),substr(x,7,8),sep='/'),timezone='UTC')[1]
return(y)
}
sun.set <- function(x){
y <- sunrise.set(centY,centX,paste(substr(x,1,4),substr(x,5,6),substr(x,7,8),sep='/'),timezone='UTC')[2]
return(y)
}
#Deal with missing night time data
sunrise <- melt.data.table(as.data.table(lapply(times$datetime,sun.rise)),variable.name = 'date', value.name='posTime')
#Deal with missing night time data
sunrise <- melt.data.table(as.data.table(lapply(times$datetime[5000],sun.rise)),variable.name = 'date', value.name='posTime')
#Deal with missing night time data
sunrise <- melt.data.table(as.data.table(lapply(times$datetime,sun.rise)),variable.name = 'date', value.name='posTime')
sunrise[,chr:=seq(length(unique(times$chr)))][,riseTime:=as.numeric(substr(as.character(ymd_hms(posTime)),12,13))]
sunrise$date<-substr(sunrise$posTime,1,10)
sunrise<-sunrise[,.(chr,riseTime)]
#sunrise<-sunrise[,.(chr,riseTime)]
setkey(sunrise,chr)
sunset <- melt.data.table(as.data.table(lapply(times$datetime,sun.set)),variable.name = 'date',value.name='posTime')
sunset[,chr:=seq(length(unique(times$chr)))][,setTime:=as.numeric(substr(as.character(ymd_hms(posTime)),12,13))]
sunset$date<-substr(sunset$posTime,1,10)
sunset<-sunset[,.(chr,setTime)]
#sunset <- sunset[,.(chr,setTime)]
setkey(sunset,chr)
#dm2<-copy(dm)
dm[,chr := .GRP, by = .(datetime)]
setkey(dm,chr)
dm <- sunrise[dm]
dm <- sunset[dm]
invisible(gc())
dm
dm[swrad<=0,swrad:=NA]
dm[is.na(swrad) & setTime<riseTime & as.numeric(substr(datetime,9,10))<=riseTime+1 & as.numeric(substr(datetime,9,10))>=setTime-1,swrad:=0]
dm
dm[is.na(swrad) & setTime>riseTime & as.numeric(substr(datetime,9,10))<=riseTime+1,swrad:=0]
dm[is.na(swrad) & setTime>riseTime & as.numeric(substr(datetime,9,10))>=setTime-1,swrad:=0]
dm
setorder(dm,y,x,chr)
len <- dim(dm[chr==1])[1]
dm[,Index := .GRP, by = .(x,y)]
dm
dm <- dm[,.(Index,x,y,datetime,chr,swrad)]
#rap2[,tempK:=round(tempK,2)][,swrad:=round(swrad,2)]
setnames(dm,'chr','HOY')
dm$sw_inter<-dm$swrad
dm
for (i in unique(dm$Index)){#[1:length(unique(clima.dt$Index))]){
ind<-which(dm$Index==i)
#clima.dt$sw_inter[ind]<-na.spline(clima.dt$sw_inter[ind])
dm$sw_inter[ind]<-na.spline(dm$sw_inter[ind])
##if (i==1){
##  ind_length<-sum(is.na(clima.dt$swRad[ind]))
##}else{
##  ind_length<-append(ind_length,sum(is.na(clima.dt$swRad[ind])))
##}
print(i)
}
dm$sw_test<-dm$sw_inter
dm
#Remove interpolated values that are above or below measured values
#hrs<-unique(dm$HOY[dm$sw_inter < -0.01])
hrs<-unique(dm$HOY[dm$sw_inter < min(dm$swrad,na.rm=TRUE) | dm$sw_inter > max(dm$swrad,na.rm=TRUE)])
for (h in hrs) {
#idx<-which(dm$sw_inter<0 & dm$HOY==h)
idx<-which((dm$sw_inter< min(dm$swrad,na.rm=TRUE) | dm$sw_inter> max(dm$swrad,na.rm=TRUE)) & dm$HOY==h)
for (i in idx){
id<-which(dm$x <= dm$x[i]+0.06 & dm$x >= dm$x[i]-0.06 & dm$y <= dm$y[i]+0.06 & dm$y >= dm$y[i]-0.06 & dm$HOY==h)
#xvals<-unique(dm$x[dm$x <= dm$x[i]+0.06 & dm$x >= dm$x[i]-0.06])
#yvals<-unique(dm$x[dm$x <= dm$x[i]+0.06 & dm$x >= dm$x[i]-0.06])
#print(c(dm$x[i],id))#vals))
n<-sum(is.na(dm$swrad[id]))
if(n>=length(id)-1){#if there is 1 or less pixel that is not NA
dm$sw_test[i]<-mean(dm$swrad[dm$HOY==h],na.rm=TRUE) #take the mean of the entire scene
#print(paste(h,i,'scene',sep=' '))
}else{
dm$sw_test[i]<-mean(dm$swrad[id],na.rm=TRUE)
}
#dm$sw_test[i]<-mean(dm$swrad[id],na.rm=TRUE)
#print(c(h,i,id))
}
print(h)
#for (i in length(dm$x[idx])){
#  print(paste0("x: "+str(dm$x[idx][i])+"surrounding: "+str(vals[i])))
#}
}
dm
#replace any remaining values outside of the range with the minimum and maximum of the range
dm$sw_test[dm$sw_inter < min(dm$swrad,na.rm=TRUE) & is.na(dm$sw_test)] <-0
dm$sw_test[dm$sw_inter > max(dm$swrad,na.rm=TRUE) & is.na(dm$sw_test)] <- max(dm$swrad,na.rm=TRUE)
dm
memory.limit(size=5e8)
library(StreamMetabolism)
library(rgdal)
library(zoo)
library(purrr)
library(data.table)
library(ncdf4)
library(raster)
library(sp)
library(parallel)
library(lubridate)
setwd('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files')
# define study domain, city and year
xmin = -79.9333-4/240
xmax = -79.9333+4/240
ymin = 44.3167-4/240
ymax = 44.3167+4/240
city = 'Borden_500m_V061_adjusted_R_2019'
yr = 2018
# Set input and create output files directories
#inDIR <- paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/GOES/2019/origTIFF/')
outDIR <- paste0(city,'/',yr)
# Time file
times <- fread(paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/RAP/2018/times',yr,'.csv')) # times data in /urbanVPRM_30m/driver_data/times/
setkey(times,chr)
# CRS list
#LANDSAT_CRS = "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
RAP_CRS = "+proj=lcc +lat_1=25 +lat_2=25 +lat_0=25 +lon_0=265 +x_0=0 +y_0=0 +a=6371229 +b=6371229 +units=m +no_defs"
GOES_CRS = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 "
MODIS_CRS = "+proj=longlat +datum=WGS84 +no_defs"
# Import raster of study domain and convert to SpatialPoints object for resampling
#ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/TPD/landsat/landsat8/ls_TPD2018_0203_8_2km_all_bands.tif') # landsat data in /urbanVPRM_30m/driver_data/landsat/
ls <- raster('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/Borden_500m_V061_adjusted_R_2018/LandCover/MODIS_LC_Borden_500m_V061_adjusted_R_2018.tif')
npixel <- ncell(ls)
values(ls) <- 1
ls.spdf <- as(ls,'SpatialPointsDataFrame')
# Create slightly larger bounding box to crop to (avoids dropped pixels at edge when reprojecting / resampling)
bbox <- extent(xmin,xmax,ymin,ymax)
buff=0.05
bbox.extra <- extent(xmin - buff, xmax + buff, ymin - buff, ymax + buff)
ls
# Create extended bounding box raster in GOES projection
gridXY = as(raster::extent(bbox.extra), "SpatialPolygons")
proj4string(gridXY) = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
GOES.XY <- projectRaster(raster(gridXY),crs=GOES_CRS)
GOES.XY
print("done! 1")
goes_data<-readRDS("C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/Borden_500m_V061_adjusted_R_2018/pre_processed_GOES/goes_Borden_2018_pre_processed_mean_filling_NA_rm.rds")
goes_data
goes_data<-goes_data[,.(x,y,datetime,sw_test)]
outlist<-NULL
for (d in unique(goes_data$datetime)){
m<-copy(ls)
#print(paste0("Processing ",d))
godat<-rasterFromXYZ(goes_data[goes_data$datetime==d])
godat<-godat$sw_test
crs(godat)<-GOES_CRS
#godat<-crop(godat,extent(GOES.XY))
#godat<-projectRaster(godat,crs=MODIS_CRS)
vals<- extract(godat,ls.spdf)
values(m)<-vals
outlist<-append(outlist,m)
}
godat
outlist
vals
m
plot(outlist[1])
outlist[1]
outlist[999]
outlist[[999]]
plot(outlist[[999]])
print("done! 2")
# run function
#outlist <- mcmapply(goes2modis, dir=inDIR, file=rl, mc.cores=1)
rm(ls,ls.spdf,GOES.XY)
# Compile all cropped and reprojected hourly rasters into single "long" data.table
cnames <- as.character(times$datetime)#substr(rl,1,10)
st = stack(outlist)
dt <- as.data.table(as.data.frame(st,xy=T))
setnames(dt,c('x','y',cnames))
print("saved dt")
dt <- setDT(dt)
dt
dt$2018010419
dt$2018032505
dt[1]
dm <- melt.data.table(dt,id.vars=c('x','y'),variable.name='datetime',value.name='swrad',variable.factor=F)
dm[,datetime:=as.character(datetime)][,swrad:=as.numeric(swrad)]
setkey(dm,x,y,datetime)
dm
dm$swrad
# Climate data folder we can use the updated version since the RAP and GOES scripts are the same between versions
dir_clima = paste0('C:/Users/kitty/Documents/Research/SIF/UrbanVPRM/UrbanVPRM/dataverse_files/Borden_V061_500m_2018/2018') # climate data in /urbanVPRM_30m/driver_data/rap_goes/
#if(length(blocks)>1){
#  clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_",yr,"_hourly_block_",sprintf("%08i",as.numeric(block)),".rds"))
#} else {
#clima.dt = readRDS(paste0(dir_clima,"/rap_goes_",city,"_hourly.rds"))
clima.dt = readRDS(paste0(dir_clima,"/rap_goes_Borden_V061_500m_2018_hourly_fixed.rds"))
clima.dt
plot(outlist[[999]])
outlist[[999]]
cnames[999]
dm[dm$\]
dm[dm$datetime==cnames[999]]
ggplot(dm[dm$datetime==cnames[999]])
library("ggplot2") #not needed for running just visualizing
typeof(dm)
ggplot(dm[dm$datetime==cnames[999]],                       # Draw ggplot2 plot
#       aes(x = x, y = y, width=1/240,
#           height=1/240)) + geom_tile(aes(fill=swrad))
ggplot(dm[dm$datetime==cnames[999]],                       # Draw ggplot2 plot
#       aes(x = x, y = y, width=1/240,
#           height=1/240)) + geom_tile(aes(fill=swrad)))
)
))))
ggplot(dm[dm$datetime==cnames[999]],                       # Draw ggplot2 plot
#       aes(x = x, y = y, width=1/240,
#           height=1/240)) + geom_tile(aes(fill=dm$swrad))
ggplot(dm[dm$datetime==cnames[999]],                       # Draw ggplot2 plot
#       aes(x = dm[dm$datetime==cnames[999]]$x, y = dm[dm$datetime==cnames[999]]$y, width=1/240,
#           height=1/240)) + geom_tile(aes(fill=dm[dm$datetime==cnames[999]]$swrad))
dm[dm$datetime==cnames[999]]
as.data.frame(dm[dm$datetime==cnames[999]])
ggplot(as.data.frame(dm[dm$datetime==cnames[999]]),                       # Draw ggplot2 plot
#       aes(x = x, y = y, width=1/240,
#           height=1/240)) + geom_tile(aes(fill=swrad))
ggplot(as.data.frame(dm[dm$datetime==cnames[999]),aes(x = x, y = y, width=1/240,height=1/240)) + geom_tile(aes(fill=swrad))
ggplot(as.data.frame(dm[dm$datetime==cnames[999]]),aes(x = x, y = y, width=1/240,height=1/240)) + geom_tile(aes(fill=swrad))
